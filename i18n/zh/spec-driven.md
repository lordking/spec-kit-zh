# 规格驱动开发（SDD）

## 权力倒置

几十年来，代码一直是王者。规格服务于代码——它们是我们在先搭建然后在开始"真正工作"时丢弃的脚手架。我们编写PRD来指导开发，创建设计文档来告知实现，绘制图表来可视化架构。但这些总是从属于代码本身。代码就是真理。充其量，其他一切都是良好的意图。代码是真理的源泉，随着它的推进，规格很少能跟上步伐。由于资产（代码）和实现是一体的，如果不试图从代码构建，就很难有一个并行实现。

规格驱动开发（SDD）颠覆了这种权力结构。规格不服务于代码，而是代码服务于规格。产品需求文档（PRD）不是实现的指南，而是生成实现的源头。技术计划不是解释编码的文档，而是产生代码的精确定义。这不是对我们如何构建软件的增量改进。这是对驱动开发因素的彻底重新思考。

规格与实现之间的差距自软件开发诞生以来就困扰着我们。我们试图通过更好的文档、更详细的需求、更严格的流程来弥合这些差距。这些方法失败是因为软件开发者们不可避免地接受差距。他们试图缩小差距但从未消除这些差距。SDD通过使规格及其从规格中产生的具体实施计划可执行来消除差距。当规格和实施计划生成代码时，就不存在差距——只有转换。

这种转换现在成为可能，因为AI能够理解复杂的规格并创建详细的实施计划。但没有结构的原始AI生成会产生混乱。SDD通过精确、完整且足以生成工作系统的规格和后续实施计划提供这种结构。规格成为主要产物。代码成为其在特定语言和框架中的表达（作为来自实施计划的实现）。

在这个新世界中，维护软件意味着演进规格。开发团队的意图用自然语言（"**意图驱动开发**"）、设计资产、核心原则和其他指导方针来表达。开发的**通用语言**提升到更高层次，代码是最后一公里的方法。

调试意味着修复生成错误代码的规格及其实施计划。重构意味着为清晰度而重组。整个开发工作流程围绕规格作为真理的中心来源重新组织，实施计划和代码作为不断再生的输出。更新应用以添加新功能或创建新的并行实现，因为我们是有创造力的生物，意味着重新审视规格并创建新的实施计划。因此这个过程是 0 -> 1, (1', ..), 2, 3, N。

开发团队专注于他们的创造力、实验和批判性思维。

## SDD工作流程实践

工作流程从一个想法开始——通常模糊且不完整。通过与AI的迭代对话，这个想法变成全面的PRD。AI提出需要澄清的问题，识别边缘情况，并帮助定义精确的验收标准。在传统开发中可能需要数天会议和文档的工作，在数小时的专注规格中完成。这改变了传统的SDLC——需求和设计成为持续活动而不是离散阶段。这支持**团队流程**，团队审查的规格被表达和版本化，在分支中创建并合并。

当产品经理更新验收标准时，实施计划会自动标记受影响的技术决策。当架构师发现更好的模式时，PRD会更新以反映新的可能性。

在整个规格过程中，研究代理收集关键上下文。他们调查库兼容性、性能基准和安全影响。组织约束被自动发现和应用——你公司的数据库标准、认证要求和部署策略无缝集成到每个规格中。

从PRD开始，AI生成将需求映射到技术决策的实施计划。每项技术选择都有记录的理由。每项架构决策都追溯到特定需求。在这个过程中，一致性验证持续提高质量。AI分析规格中的歧义、矛盾和差距——不是作为一次性关卡，而是作为持续改进。

代码生成在规格和其实施计划足够稳定时就开始，但它们不需要是"完整的"。早期生成可能是探索性的——测试规格在实践中是否有意义。领域概念成为数据模型。用户故事成为API端点。验收场景成为测试。这通过规格合并开发和测试——测试场景不是在代码之后编写，而是作为生成实现和测试的规格的一部分。

反馈循环扩展到初始开发之外。生产指标和事件不仅仅触发热修复——它们为下一次再生更新规格。性能瓶颈成为新的非功能需求。安全漏洞成为影响所有未来生成的约束。规格、实施和运营现实之间的这种迭代舞蹈是真正理解产生的地方，也是传统SDLC转化为持续演进的地方。

## 为什么SDD现在变得重要

三个趋势使SDD不仅可能而且必要：

首先，AI能力已达到自然语言规格能够可靠生成工作代码的阈值。这不是关于替换开发人员——而是通过从规格到实现的自动化的机械翻译来放大他们的有效性。它可以放大探索和创造力，轻松支持"重新开始"，并支持增删和批判性思维。

其次，软件复杂性持续呈指数增长。现代系统集成了数十种服务、框架和依赖项。通过手动流程保持所有这些部分与原始意图对齐变得越来越困难。SDD通过规格驱动的生成提供系统性对齐。框架可能演进以提供AI优先支持，而不是人类优先支持，或围绕可重用组件进行架构。

第三，变化步伐加速。今天需求变化比以往任何时候都要快得多。转向不再例外——它是预期的。现代产品开发需要基于用户反馈、市场条件和竞争压力的快速迭代。传统开发将这些变化视为中断。每次转向都需要通过文档、设计和代码手动传播变化。结果是限制速度的缓慢仔细更新，或累积技术债务的快速不计后果的变化。

SDD可以支持假设/模拟实验："如果我们需要重新实现或更改应用程序以促进销售更多T恤的业务需求，我们将如何为此实施和实验？"

SDD将需求变化从障碍转化为正常工作流程。当规格驱动实现时，转向成为系统性再生而不是手动重写。在PRD中更改核心需求，受影响的实施计划会自动更新。修改用户故事，相应的API端点会再生。这不仅仅是关于初始开发——而是关于通过不可避免的变化保持工程速度。

## 核心原则

**规格作为通用语言**：规格成为主要产物。代码成为其在特定语言和框架中的表达。维护软件意味着演进规格。

**可执行规格**：规格必须足够精确、完整和明确以生成工作系统。这消除了意图和实现之间的差距。

**持续改进**：一致性验证持续进行，而不是作为一次性关卡。AI分析规格中的歧义、矛盾和差距作为持续过程。

**研究驱动上下文**：研究代理在整个规格过程中收集的关键上下文，调查技术选项、性能影响和组织约束。

**双向反馈**：生产事实推动规格演进。指标、事件和运营学习成为规格演进的输入。

**探索分支**：从同一规格生成多种实施方法，以探索不同的优化目标——性能、可维护性、用户体验、成本。

## 实施方法

今天，实践SDD需要组装现有工具并在整个过程中保持纪律。该方法可以通过以下方式实践：

- 用于迭代规格开发的AI助手
- 用于收集技术上下文的研究型代理
- 用于将规格转换为实施的代码生成工具
- 适用于规格优先工作流程的版本控制系统
- 通过AI分析规格文档进行一致性检查

关键是将规格视为真理的源泉，代码作为为规格服务的生成输出，而不是相反。

## 使用命令简化SDD

SDD方法通过三个强大的命令得到显著增强，这些命令自动化“规格 → 计划 → 任务”工作流程：

### `/speckit.specify` 命令

此命令将简单的功能描述（用户提示）转换为完整的结构化规格，并带有自动仓库管理：

1. **自动功能编号**：扫描现有规格以确定下一个功能编号（例如001、002、003）
2. **分支创建**：从你的描述生成语义分支名称并自动创建
3. **基于模板的生成**：使用你的需求复制和自定义功能规格模板
4. **目录结构**：为所有相关文档创建适当的`specs/[branch-name]/`结构

### `/speckit.plan` 命令

一旦存在功能规格，此命令创建全面的实施计划：

1. **规格分析**：读取并理解功能需求、用户故事和验收标准
2. **宪章合规**：确保与项目宪章和架构原则的对齐
3. **技术转换**：将业务需求转换为技术架构和实施细节
4. **详细文档**：生成数据模型、API合约和测试场景的支持文档
5. **快速开始验证**：生成捕获关键验证场景的快速开始指南

### `/speckit.tasks` 命令

创建计划后，此命令分析计划和相关设计文档以生成可执行任务列表：

1. **输入**：读取`plan.md`（必需）以及如果存在`data-model.md`、`contracts/`和`research.md`
2. **任务派生**：将合约、实体和场景转换为特定任务
3. **并行化**：标记独立任务`[P]`并概述安全的并行组
4. **输出**：在功能目录中写入`tasks.md`，准备由任务代理执行

### 示例：构建聊天功能

这些命令如何转变传统开发工作流程如下：

**传统方法：**

```text
1. 在文档中编写PRD（2-3小时）
2. 创建设计文档（2-3小时）
3. 手动设置项目结构（30分钟）
4. 编写技术规格（3-4小时）
5. 创建测试计划（2小时）
总计：~12小时的文档工作
```

**使用命令的SDD方法：**

```bash
# 步骤1：创建功能规格（5分钟）
/speckit.specify 支持消息历史记录和用户在线状态的实时聊天系统

# 这自动：
# - 创建分支"003-chat-system"
# - 生成specs/003-chat-system/spec.md
# - 用结构化需求填充它

# 步骤2：生成实施计划（5分钟）
/speckit.plan 使用WebSocket进行实时消息传递，使用PostgreSQL存储历史记录，使用Redis管理用户在线状态

# 步骤3：生成可执行任务（5分钟）
/speckit.tasks

# 这自动创建：
# - specs/003-chat-system/plan.md
# - specs/003-chat-system/research.md（WebSocket库比较）
# - specs/003-chat-system/data-model.md（消息和用户模式）
# - specs/003-chat-system/contracts/（WebSocket事件，REST端点）
# - specs/003-chat-system/quickstart.md（关键验证场景）
# - specs/003-chat-system/tasks.md（从计划派生的任务列表）
```

在15分钟内，你拥有：

- 具有用户故事和验收标准的完整功能规格
- 具有技术选择和理由的详细实施计划
- 准备好进行代码生成的API合约和数据模型
- 用于自动化和手动测试的综合测试场景
- 在功能分支中正确版本化的所有文档

### 结构化自动化的力量

这些命令不仅仅节省时间——它们强制一致性和完整性：

1. **无遗忘细节**：模板确保考虑每个方面，从非功能需求到错误处理
2. **可追溯决策**：每项技术选择都链接回特定需求
3. **活文档**：规格与代码保持同步，因为它们生成代码
4. **快速迭代**：更改需求并在几分钟而不是几天内再生计划

这些命令体现了SDD原则，将规格视为可执行产物而不是静态文档。它们将规格过程从必要之恶转变为开发的驱动力。

### 模板驱动的质量：结构如何约束LLM以获得更好的结果

这些命令的真正力量不仅在于自动化，还在于模板如何引导LLM行为朝向更高质量的规格。模板作为复杂的提示，以富有成效的方式约束LLM的输出：

#### 1. **防止过早的实现细节**

功能规格模板明确指示：

```text
- ✅ 专注于用户需要什么以及为什么
- ❌ 避免如何实现（没有技术栈、API、代码结构）
```

这种约束迫使LLM保持适当的抽象级别。当LLM可能自然跳到"使用React with Redux实现"时，模板使其专注于"用户需要实时更新他们的数据"。这种分离确保规格保持稳定，即使实现技术发生变化。

#### 2. **强制显式不确定性标记**

两个模板都强制使用`[NEEDS CLARIFICATION]`标记：

```text
从用户提示创建此规格时：
1. **标记所有歧义**：使用[NEEDS CLARIFICATION: specific question]
2. **不要猜测**：如果提示没有指定某些东西，标记它
```

这防止了LLM做出合理但可能错误的常见行为。不是猜测"登录系统"使用电子邮件/密码认证，LLM必须将其标记为`[NEEDS CLARIFICATION: auth method not specified - email/password, SSO, OAuth?]`。

#### 3. **通过清单进行结构化思考**

模板包括作为规格"单元测试"的全面的清单：

```markdown
### 需求完整性

- [ ] 没有剩余的[NEEDS CLARIFICATION]标记
- [ ] 需求是可测试的和明确的
- [ ] 成功标准是可衡量的
```

这些清单迫使LLM系统地自我审查其输出，捕捉否则可能滑过的差距。这就像给LLM一个质量保证框架。

#### 4. **通过关卡的宪章合规**

实施计划模板通过阶段关卡强制架构原则：

```markdown
### 阶段-1：实施前关卡

#### 简洁关卡（第VII条）

- [ ] 使用≤3个项目？
- [ ] 没有过度设计？

#### 反抽象关卡（第VIII条）

- [ ] 直接使用框架？
- [ ] 单一模型表示？
```

这些关卡通过使LLM明确证明任何复杂性来防止过度工程。如果关卡失败，LLM必须在"复杂性跟踪"部分记录原因，为架构决策创建问责制。

#### 5. **分层细节管理**

模板强制适当的信息架构：

```text
**重要**：此实施计划应保持高层且可读。
任何代码示例、详细算法或广泛的技术规格
必须放置在适当的`implementation-details/`文件中
```

这防止了规格变得不可读的代码转储的常见问题。LLM学会保持适当的细节级别，将复杂性提取到单独的文件中，同时保持主文档可导航。

#### 6. **测试优先思维**

实施模板强制测试优先开发：

```text
### 文件创建顺序
1. 创建带有API规格的`contracts/`
2. 按顺序创建测试文件：契约 → 集成 → e2e → 单元
3. 创建源文件使测试通过
```

这种排序约束确保LLM在实现之前考虑可测试性和契约，导致更稳健和可验证的规格。

#### 7. **防止投机功能**

模板明确劝阻投机：

```text
- [ ] 没有投机或"可能需要"的功能
- [ ] 所有阶段都有明确的先决条件和可交付成果
```

这阻止了LLM添加使实现复杂的"好有可无"功能。每个功能都必须追溯到具有明确验收标准的具体用户故事。

### 复合效应

这些约束共同产生规格：

- **完整**：清单确保没有遗忘
- **明确**：强制澄清标记突出不确定性
- **可测试**：测试优先思维融入过程
- **可维护**：适当的抽象级别和信息层次结构
- **可实施**：具有具体可交付成果的明确阶段

模板将LLM从创造性作家转变为纪律严明的规格工程师，将其能力引导向产生真正驱动开发的一致高质量、可执行规格。

## 宪章基础：强制架构纪律

SDD的核心是宪章——一套不可变的原则，管理规格如何成为代码。宪章（`memory/constitution.md`）作为系统的架构DNA，确保每个生成的实现都保持一致性、简洁性和质量。

### 发展九条款

宪章定义了塑造开发过程每个方面的九个条款：

#### 第一条：库优先原则

每个功能都必须从独立库开始——没有例外。这从一开始就强制模块化设计：

```text
指定中的每个功能都必须以独立库的存在开始。
不得在应用程序代码中直接实现任何功能，
除非首先将其抽象为可重用库组件。
```

这个原则确保规格生成模块化、可重用的代码而不是单体应用程序。当LLM生成实施计划时，它必须将功能结构化为具有清晰边界和最小依赖的库。

#### 第二条：CLI接口授权

每个库都必须通过命令行接口公开其功能：

```text
所有CLI接口必须：
- 接受文本作为输入（通过stdin、参数或文件）
- 产生文本作为输出（通过stdout）
- 支持JSON格式进行结构化数据交换
```

这强制可观察性和可测试性。LLM无法将功能隐藏在不透明的类中——一切都必须通过基于文本的接口可访问和可验证。

#### 第三条：测试优先命令

最具变革性的条款——测试前无代码：

```text
这是不可协商的：所有实施必须遵循严格的测试驱动开发。
在以下之前不得编写任何实施代码：
1. 编写单元测试
2. 测试被用户验证和批准
3. 测试确认失败（红色阶段）
```

这完全颠覆了传统的AI代码生成。LLM不是生成代码并希望它工作，而是必须首先生成定义行为的综合测试，获得批准，然后才生成实施。

#### 第七条和第八条：简洁性和反抽象

这些配对条款对抗过度工程：

```text
第7.3节：最小项目结构
- 初始实施最多3个项目
- 额外项目需要记录的理由

第8.1节：框架信任
- 直接使用框架功能而不是包装它们
```

当LLM可能自然创建复杂抽象时，这些条款强制它证明每一层复杂性。实施计划模板的"阶段-1关卡"直接强制这些原则。

#### 第九条：集成优先测试

优先考虑真实世界测试而不是隔离的单元测试：

```text
测试必须使用真实环境：
- 偏好真实数据库而不是模拟
- 使用实际服务实例而不是存根
- 实施前强制进行契约测试
```

这确保生成的代码在实践中工作，而不仅仅是在理论上。

### 通过模板强制宪章

实施计划模板通过具体检查点使这些条款可操作：

```markdown
### 阶段-1：实施前关卡

#### 简洁关卡（第VII条）

- [ ] 使用≤3个项目？
- [ ] 没有过度设计？

#### 反抽象关卡（第VIII条）

- [ ] 直接使用框架？
- [ ] 单一模型表示？

#### 集成优先关卡（第IX条）

- [ ] 定义了契约？
- [ ] 编写了契约测试？
```

这些关卡充当架构原则的编译时检查。LLM无法继续，除非通过关卡或在"复杂性跟踪"部分记录合理例外。

### 不可变原则的力量

宪章的力量在于其不可变性。虽然实施细节可以演进，但核心原则保持不变。这提供：

1. **跨时间一致性**：今天生成的代码遵循与明年生成的代码相同的原则
2. **跨LLM一致性**：不同的AI模型产生架构兼容的代码
3. **架构完整性**：每个功能都强化而不是破坏系统设计
4. **质量保证**：测试优先、库优先和简洁原则确保可维护的代码

### 宪章演进

虽然原则是不可变的，但其应用可以演进：

```text
第4.2节：修正过程
修改此宪章需要：
- 明确记录更改的理由
- 项目维护者的审查和批准
- 向后兼容性评估
```

这允许方法在学习的同时保持稳定性。宪章通过带日期的修正显示自己的演进，展示了如何基于现实世界经验完善原则。

### 超越规则：开发哲学

宪章不仅仅是一本规则书——它是一种塑造LLM如何思考代码生成的哲学：

- **可观察性胜过不透明**：一切都必须通过CLI接口可检查
- **简洁性胜过聪明**：从简单开始，只有在证明必要时才添加复杂性
- **集成胜过隔离**：在真实环境中测试，而不是人工环境
- **模块化胜过单体**：每个功能都是具有清晰边界的库

通过将这些原则嵌入规格和计划过程，SDD确保生成的代码不仅仅是功能性的——它是可维护、可测试和架构合理的。宪章将AI从代码生成器转变为尊重和强化系统设计原则的架构伙伴。

## 转型

这不是关于替换开发人员或自动化创造力。这是关于通过自动化机械翻译来放大人类能力。这是关于创建紧密的反馈循环，规格、研究和代码一起演进，每次迭代都带来对意图和实现之间对齐的更深入理解。

软件开发需要更好的工具来保持意图和实现之间的对齐。SDD提供了通过可执行规格生成代码而不是仅仅指导它来达到这种对齐的方法。
