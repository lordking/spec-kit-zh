---
description: 通过提出最多 5 个高度针对性的澄清问题，识别当前功能规格中说明不足的区域，并将答案编码回规格中。
handoffs:
  - label: 构建技术计划
    agent: speckit.plan
    prompt: 为规格创建计划。我正在构建...
scripts:
   sh: scripts/bash/check-prerequisites.sh --json --paths-only
   ps: scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly
---

## 用户输入

```text
$ARGUMENTS
```

（如果不为空）在进行之前，你**必须**考虑用户输入。

## 大纲

目标：检测并消除当前功能规格中的模糊点或缺失的决策项，并将澄清的结论直接记录到规格文件中。

注意：此澄清工作流预计在调用 `/speckit.plan` 之前运行（并完成）。如果用户明确表示跳过澄清（例如探索性验证），则可以继续，但必须警告将会增加下游返工风险。

执行步骤：

1. 从仓库根目录运行**一次** `{SCRIPT}`（使用组合模式 `--json --paths-only`  / `-Json -PathsOnly`）。解析必要的 JSON 字段：
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - （可选捕获 `IMPL_PLAN`、`TASKS` 以供后续流程使用。）
   - 如果 JSON 解析失败，中止并提示用户重新运行 `/speckit.specify` 或检查功能分支环境。
   - 对于参数中的单引号，如 "I'm Groot"，使用转义语法：例如 'I'\''m Groot'（或者如果可能，也可以使用双引号："I'm Groot"）。

2. 加载当前规格文件。使用以下分类执行结构化模糊性与覆盖率扫描。为每个类别标记状态：清晰/部分/缺失。生成用于优先级排序的内部覆盖率图谱（除非后续无需提问，否则不要输出此图谱）。

   功能范围与行为：
   - 核心用户目标和成功标准
   - 明确的排除范围声明
   - 用户角色/用户画像区分

   领域与数据模型：
   - 实体、属性、关系
   - 标识与唯一性规则
   - 生命周期/状态转换
   - 数据量/规模假设

   交互与用户体验流程：
   - 关键用户旅程/操作序列
   - 错误/空数据/加载状态
   - 无障碍访问或本地化说明

   非功能性质量属性：
   - 性能（延迟、吞吐量目标）
   - 可扩展性（水平/垂直扩展、资源限制）
   - 可靠性与可用性（正常运行时间、恢复预期）
   - 可观测性（日志、指标、跟踪信号）
   - 安全与隐私（身份认证/授权、数据保护、威胁假设）
   - 合规性/监管约束（如有）

   集成与外部依赖：
   - 外部服务/API 及其故障模式
   - 数据导入/导出格式
   - 协议/版本假设

   边界情况与失败处理：
   - 负面场景
   - 速率限制/限流
   - 冲突解决（例如，并发编辑）

   约束与权衡：
   - 技术约束（语言、存储、部署环境）
   - 明确的权衡或已否决的替代方案

   术语与一致性：
   - 标准术语表
   - 应避免的同义词/已弃用的术语

   完成信号：
   - 可测试的验收标准
   - 可衡量的“完成定义”类型指标

   杂项/占位符：
   - TODO 标记/未解决的决策
   - 缺乏量化的模糊的形容词（例如"健壮"、"直观"）

   对于每个具有部分或缺失状态的类别，生成一个候选澄清问题，除非：
   - 澄清不会实质性影响实现或验证策略
   - 该信息更适合推迟到规划阶段处理（内部记录）

3. （内部）生成一个优先级排序的候选澄清问题队列（最多 5 个）。不要一次输出所有问题。应用以下约束：
    - 整个会话中问题总数不超过 10 个。
    - 每个问题必须使用**以下之一**的形式回答：
       - 简短的多项选择（2-5 个互斥的不同选项），或
       - 一个词/短语的回答（明确的约束："请用 ≤5 个词回答"。）
    - 包含的答案必须实质性影响软件架构、数据建模、任务分解、测试设计、用户体验、运维就绪性或合规验证的问题。
    - 确保类别覆盖平衡：优先解决影响最大且未解决的类别；避免在一个高影响领域（如安全态势）未明确时，追问两个低影响问题。
    - 排除已解答的问题、琐碎的风格偏好，或计划层面的执行细节（除非其阻塞正确性）。
    - 优先选择能降低下游返工风险或防止验收测试不一致的澄清点。
    - 如果超过 5 个类别未明确，按（影响范围 * 不确定性）启发式方法选择前 5 个。

4. 顺序提问循环（交互式）：
    - 一次恰好仅呈现**一个问题**。*
    - 对于多选题：
       - **分析所有选项**，并根据以下因素确定**最合适的选项**：
          - 该类项目类型的最佳实践
          - 类似实现的常见模式
          - 风险降低（安全、性能、可维护性）
          - 与规格中任何可见的项目目标或约束的一致性
       - 在顶部突出显示你的**推荐选项**，并提供清晰的理由（1-2 句话解释为什么这是最佳选择）。
       - 格式：`**推荐：** 选项 [X] - <理由>`
       - 然后以 Markdown 表格形式列出所有选项：

       | 选项 | 描述 |
       |--------|-------------|
       | A | <选项 A 描述> |
       | B | <选项 B 描述> |
       | C | <选项 C 描述>（可按需添加 D/E，最多 5 项） |
       | 简短答案 | 提供不同的简短回答（≤5 词）（仅在适合自由回答时包含此项） |

       - 在表格后添加：`你可以回复选项字母（例如“A”），通过说“是/yes”或“推荐/recommended”接受推荐，或提供你自己的简单答案。`
    - 对于简答题（无明确的离散选项时）：
       - 根据最佳实践和上下文提供你的**建议答案**。*
       - 格式为：`**建议：** <你的提议答案> - <简要理由>`
       - 然后输出`格式：简短回答（≤5 词）。你可以通过说“是/yes”或“建议/suggested”接受该建议，或提供你自己的答案。`
    - 用户回答后：
       - 如果用户回复"是/yes"、"推荐/recommended"或者"建议/suggested"，则使用你之前陈述的推荐/建议作为答案。
       - 否则，验证答案是否匹配某个选项或符合 ≤5 词的约束。
       - 答案模糊，请求快速澄清（此过程仍属同一问题，不要推进下一个问题）。
       - 当答案被确认后，将其记录在工作记忆中（暂不写入磁盘），并移至队列中的下一个问题。
    - 当出现以下情况时停止进一步提问：
       - 所有关键模糊点已提前解决（剩余队列项不再必要），或
       - 用户发出完成信号（"完成/done"、"好了/good"、"没有更多/no more"），或
       - 已提问 5 个问题。
    - 永远不要提前透露队列中后续的问题。
    - 如果开始时就没有有效问题，则立即报告没有发现关键模糊点。

5. 在接受每个答案后进行集成（在每次接受答案后增量更新）：
    - 保持规格在内存中的表述（开始时加载一次）以及原始文件内容。
    - 对于本次会话的第一个集成答案：
       - 确保存在章节 `## 澄清记录` 章节（如果不存在，则根据规格模板，在最高层级的上下文或概述章节后创建）。
       - 在该章节下，为今天创建一个子标题 `### 会话记录【YYYY-MM-DD】` （如果不存在）。
    - 在接受答案后立即追加条目：`- Q: <问题> → A: <最终答案>`。
    - 立即将澄清内容应用到最合适的章节：
       - 功能模糊 → 在功能需求中更新或添加条目。
       - 用户交互/参与者歧义 → 在“用户故事”或“参与者”子章节（如有）中更新澄清后的角色、约束或场景。
       - 数据形态/实体 → 更新数据模型（添加字段、类型、关系），保持原有顺序；简要注明新增约束。
       - 非功能性约束 → 在“非功能性需求”/“质量属性”章节添加/修改可衡量的标准（将模糊形容词转化为指标或明确目标）。
       - 边界情况/负面流程 → 在边界情况/错误处理子章节下添加新条目（若模板提供占位符则创建该子章节）。
       - 术语冲突 → 在整个规格中统一术语；仅在必要时保留原术语，并一次性添加（此前称为“X”）说明。
    - 如果澄清使过去的模糊陈述失效，则替换原有的陈述，避免留下过时或冲突的文本。
    - 在每次集成后保存规格文件，以最小化上下文丢失风险（原子覆盖）。
    - 保留格式：不重新排序不相关的章节；保留标题的层次结构。
    - 保持每个新增的澄清内容最小且可验证（避免叙述漂移）。

6. 验证（在每次写入后执行并最后通过）：
   - 澄清会话中，每个接受的答案恰好对应一个条目（无重复）。
   - 已提问（并接受）的问题总数 ≤ 5。
   - 更新后的章节不存在本应被新答案解决但仍残留这些模糊的占位符。
   - 不存在与当前结论冲突的早期陈述（扫描并移除现已无效的备选陈述）。
   - Markdown 结构有效；仅允许新增的标题为：`## 澄清记录`、`### 会话记录【YYYY-MM-DD】`。
   - 术语一致性：所有更新的章节使用相同的标准术语。

7. 将更新后的规格写回 `FEATURE_SPEC`。

8. 报告完成（在提问循环结束或提前终止后）：
   - 已提问和已回答的问题数量。
   - 更新后规格的路径。
   - 受影响的章节（列出名称）。
   - 覆盖率汇总表，列出每个分类类别及其状态：已解决（原状态为“部分”或“缺失”的项已得到处理）、已推迟（因超出问题配额或更适合规划阶段而暂未处理）、清晰（原有描述已足够明确）、待处理（状态仍为“部分”或“缺失”的项，但影响较低）。
   - 如果存在待处理或已推迟项，向用户建议继续执行 `/speckit.plan` 或稍后在规划阶段后再次运行 `/speckit.clarify`。
   - 建议下一个命令。

行为规则：

- 如果未找到有意义的关键模糊点（或所有潜在问题都将是低影响），则回应："未检测到值得正式澄清的关键模糊点。"并建议继续。
- 如果规格文件不存在，则指示用户先运行 `/speckit.specify`（不要在此处创建新规格）。
- 提问总数永远不得超过 5 个（针对单个问题的澄清追问不计为新问题）。
- 除非缺失会阻塞功能清晰性，否则避免推测性技术栈问题。
- 尊重用户提前终止信号（"停止/stop"、"完成/done"、"继续/proceed"）。
- 如果因覆盖完全而未提出问题，则输出简要的覆盖率汇总报告（所有类别均为“清晰”），然后建议推进。
- 如果配额用尽后仍有高影响类别未解决，需在“已推迟”项下明确标出并说明原因。

用于优先级排序的上下文：{ARGS}
