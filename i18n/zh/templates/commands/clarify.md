---
description: 通过提出最多 5 个高度针对性的澄清问题，识别当前功能规格中说明不足的区域，并将答案编码回规格。
handoffs:
  - label: 构建技术计划
    agent: speckit.plan
    prompt: 为规格创建计划。我正在构建...
scripts:
   sh: scripts/bash/check-prerequisites.sh --json --paths-only
   ps: scripts/powershell/check-prerequisites.ps1 -Json -PathsOnly
---

## 用户输入

```text
$ARGUMENTS
```

在继续之前，你必须考虑用户输入（如果不为空）。

## 大纲

目标：检测并减少活动功能规格中的歧义或缺失决策点，并直接将澄清内容记录到规格文件中。

注意：此澄清工作流预计在调用 `/speckit.plan` 之前运行（并完成）。如果用户明确说明他们跳过澄清（例如，探索性 spike），你可以继续，但必须警告下游返工风险增加。

执行步骤：

1. 从仓库根目录**一次**运行 `{SCRIPT}`（组合 `--json --paths-only` 模式 / `-Json -PathsOnly`）。解析最小 JSON 负载字段：
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - （可选捕获 `IMPL_PLAN`、`TASKS` 以供未来链接流程使用。）
   - 如果 JSON 解析失败，中止并指示用户重新运行 `/speckit.specify` 或验证功能分支环境。
   - 对于参数中的单引号，如 "I'm Groot"，使用转义语法：例如 'I'\''m Groot'（或尽可能使用双引号："I'm Groot"）。

2. 加载当前规格文件。使用如下分类执行结构化的歧义和覆盖率扫描。对于每个类别，标记状态：清晰/部分/缺失。生成用于优先级排序的内部覆盖率地图（除非没有问题将被询问，否则不要输出原始地图）。

   功能范围和行为：
   - 核心用户目标和成功标准
   - 显式范围外声明
   - 用户角色/角色区分

   领域和数据模型：
   - 实体、属性、关系
   - 标识和唯一性规则
   - 生命周期/状态转换
   - 数据量/规模假设

   交互和 UX 流程：
   - 关键用户旅程/序列
   - 错误/空/加载状态
   - 可访问性或本地化注释

   非功能质量属性：
   - 性能（延迟、吞吐量目标）
   - 可扩展性（水平/垂直、限制）
   - 可靠性和可用性（正常运行时间、恢复期望）
   - 可观测性（日志记录、指标、跟踪信号）
   - 安全和隐私（authN/Z、数据保护、威胁假设）
   - 合规/监管约束（如果有）

   集成和外部依赖项：
   - 外部服务/API 和失败模式
   - 数据导入/导出格式
   - 协议/版本控制假设

   边缘情况和失败处理：
   - 负面场景
   - 速率限制/限流
   - 冲突解决（例如，并发编辑）

   约束和权衡：
   - 技术约束（语言、存储、托管）
   - 显式权衡或拒绝的替代方案

   术语和一致性：
   - 规范术语表
   - 避免的同义词/废弃的术语

   完成信号：
   - 可测试的验收标准
   - 可衡量的“完成”定义风格指标

   杂项/占位符：
   - TODO 标记/未解决的决策
   - 缺乏量化的模糊形容词（"健壮"、"直观"）

   对于每个具有部分或缺失状态的类别，添加候选问题机会，除非：
   - 澄清不会实质性改变实施或验证策略
   - 信息更适合推迟到计划阶段（内部记录）

3. 生成（内部）候选澄清问题的优先级队列（最多 5 个）。不要一次输出所有问题。应用这些约束：
    - 整个会话中总共最多 10 个问题。
    - 每个问题必须可用**以下之一**回答：
       - 简短的多项选择（2-5 个不同的、互斥的选项），或
       - 一个词/短语的答案（显式约束："用 ≤5 个词回答"。）
    - 仅包括其答案实质上影响架构、数据建模、任务分解、测试设计、UX 行为、运营就绪性或合规验证的问题。
    - 确保类别覆盖平衡：尝试首先覆盖影响最大的未解决类别；当仍有单个高影响区域（例如，安全态势）未解决时，避免询问两个低影响问题。
    - 排除已回答的问题、琐碎的风格偏好，或计划级别的执行细节（除非阻塞正确性）。
    - 优先考虑减少下游返工风险或防止对齐错误的验收测试的澄清。
    - 如果超过 5 个类别仍未解决，按（影响 * 不确定性）启发式选择前 5 个。

4. 顺序提问循环（交互式）：
    - 一次恰好呈现**一个问题**。*
    - 对于多项选择问题：
       - **分析所有选项**并根据以下确定**最合适的选项**：
          - 项目类型的最佳实践
          - 类似实现中的常见模式
          - 风险降低（安全、性能、可维护性）
          - 与规格中可见的任何显式项目目标或约束的对齐
       - 在顶部突出显示你的**推荐选项**，并提供清晰的理由（1-2 句话解释为什么这是最佳选择）。
       - 格式为：`**推荐：** 选项 [X] - <理由>`
       - 然后渲染所有选项作为 Markdown 表格：

       | 选项 | 描述 |
       |--------|-------------|
       | A | <选项 A 描述> |
       | B | <选项 B 描述> |
       | C | <选项 C 描述>（根据最多 5 个的需要添加 D/E） |
       | 短 | 提供不同的短答案（≤5 个词）（仅当自由形式替代适当时包括） |

       - 在表格后添加：`你可以用选项字母回复（例如，"A"），通过说"yes"或"recommended"接受推荐，或提供你自己的短答案。`
    - 对于短答案风格（无有意义的不同选项）：
       - 根据最佳实践和上下文提供你的**建议答案**。*
       - 格式为：`**建议：** <你的提议答案> - <简要理由>`
       - 然后输出：`格式：短答案（≤5 个词）。你可以通过说"yes"或"suggested"接受建议，或提供你自己的答案。`
    - 用户回答后：
       - 如果用户用"yes"、"recommended"或"suggested"回复，使用你之前陈述的推荐/建议作为答案。
       - 否则，验证答案映射到一个选项或符合 ≤5 个词的约束。
       - 如果模糊，要求快速消除歧义（计数仍属于同一问题；不要推进）。
       - 一旦令人满意，在工作内存中记录它（尚未写入磁盘）并移动到排队的下一个问题。
    - 当出现以下情况时停止进一步提问：
       - 提前解决所有关键歧义（剩余排队项目变得不必要），或
       - 用户发出完成信号（"done"、"good"、"no more"），或
       - 你问了 5 个问题。
    - 永远不要提前透露未来排队的问题。
    - 如果开始时没有有效问题，立即报告没有关键歧义。

5. 在接受每个答案后进行整合（增量更新方法）：
    - 维护规格的内存表示（在开始时加载一次）加上原始文件内容。
    - 对于本次会议中的第一个整合答案：
       - 确保存在 `## 澄清记录` 部分（如果不存在，请根据规格将其创建在最高级别上下文/概述部分之后）。
       - 在其下，如果不存在，则创建今天的 `### 【YYYY-MM-DD】纪要` 子标题。
    - 在接受后立即在子弹行后追加：`- Q: <问题> → A: <最终答案>`。
    - 然后立即将澄清应用到最合适的部分：
       - 功能歧义 → 在功能需求中更新或添加项目符号。
       - 用户交互/参与者区分 → 使用澄清后的角色、约束或场景更新用户故事或参与者小节（如果存在）。
       - 数据形状/实体 → 更新数据模型（添加字段、类型、关系），保留排序；简洁地记录添加的约束。
       - 非功能约束 → 在非功能/质量属性部分添加/修改可衡量标准（将模糊形容词转换为指标或显式目标）。
       - 边缘情况/负面流程 → 在边缘情况/错误处理下添加新项目符号（或创建此类小节，如果模板为其提供了占位符）。
       - 术语冲突 → 跨规格规格术语；仅在必要时通过添加一次`(以前称为"X")`来保留原始。
    - 如果澄清使之前的模糊声明无效，则替换该声明而不是复制；不留任何过时的矛盾文本。
    - 在每次整合后保存规格文件，以最小化上下文丢失的风险（原子覆盖）。
    - 保留格式：不重新排序不相关的部分；保留标题层次结构。
    - 保持每个插入的澄清最小且可测试（避免叙述漂移）。

6. 验证（在每次写入后执行并最后通过）：
   - 澄清会话恰好包含每个接受的答案的一个项目符号（无重复）。
   - 总共询问（接受）的问题 ≤5。
   - 更新的部分不包含新问题旨在解决的挥之不去的模糊占位符。
   - 没有矛盾早先声明仍然存在（扫描现已删除的已删除无效替代选择）。
   - Markdown 结构有效；仅允许的新标题：`## 澄清记录`、`### 【YYYY-MM-DD】纪要`。
   - 术语一致性：所有更新部分使用相同的规格术语。

7. 将更新后的规格写回 `FEATURE_SPEC`。

8. 报告完成（在提问循环结束或提前终止后）：
   - 询问和回答的问题数量。
   - 更新后的规格的路径。
   - 触及的部分（列出名称）。
   - 覆盖率汇总表，列出每个分类类别及其状态：已解决（部分/缺失并已解决）、推迟（超出问题配额或更适合计划）、清晰（已足够）、未解决（仍然部分/缺失但影响低）。
   - 如果任何未解决或推迟存在，建议是否继续到 `/speckit.plan` 或稍后计划后再次运行 `/speckit.clarify`。
   - 建议下一个命令。

行为规则：

- 如果未找到有意义的歧义（或所有潜在问题都将是低影响），回应："未检测到值得正式澄清的关键歧义。"并建议继续。
- 如果规格文件缺失，指示用户先运行 `/speckit.specify`（不要在此处创建新规格）。
- 永远不要超过 5 个总询问问题（单个问题的澄清重试不计为新问题）。
- 除非缺失阻塞功能清晰性，否则避免推测性技术堆栈问题。
- 尊重用户提前终止信号（"stop"、"done"、"proceed"）。
- 如果由于完整覆盖而未询问任何问题，则输出紧凑的覆盖率汇总（所有类别清晰），然后建议推进。
- 如果在配额达到时仍有未解决的高影响类别，则在推迟下明确标记并提供理由。

用于优先级排序的上下文：{ARGS}
