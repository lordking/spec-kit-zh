---
description: 从自然语言的功能描述中创建或更新功能规格。
handoffs: 
  - label: 构建技术计划
    agent: speckit.plan
    prompt: 为功能规格创建计划。我正在构建...
  - label: 澄清规格需求
    agent: speckit.clarify
    prompt: 澄清规格需求
    send: true
scripts:
  sh: scripts/bash/create-new-feature.sh --json "{ARGS}"
  ps: scripts/powershell/create-new-feature.ps1 -Json "{ARGS}"
---

## 用户输入

```text
$ARGUMENTS
```

在进行之前，你**必须**考虑用户输入（如果不为空）。

## 大纲

用户在触发消息中输入的 `/speckit.specify` 后的文本**是**功能描述。即使在下面文字中出现 `{ARGS}`，也假设你始终可以在本次对话中使用它。除非用户提供空的命令，否则不能要求用户重复输入。

基于已收到的功能描述，执行以下操作：

1. **生成短名称（short-name）**（2-4 个英文单词）用于命名功能分支：
   - 分析功能描述并提取最有意义的关键词
   - 创建一个由2-4 个英文单词组成的短名称（short-name），以捕获功能的核心
   - 尽可能使用动词-名词格式（例如，"add-user-auth"、"fix-payment-bug"）
   - 保留技术术语和缩写词（OAuth2、API、JWT 等）
   - 保持简洁但描述足以一目了然地理解功能
   - 示例：
     - "我想添加用户认证" → "user-auth"
     - "实现API的OAuth2集成" → "oauth2-api-integration"
     - "为分析创建仪表板" → "analytics-dashboard"
     - "修复支付处理超时错误" → "fix-payment-timeout"

2. **在创建新分支前检查现有分支**：

   a. 首先，获取所有远程分支以确保我们有最新信息：

      ```bash
      git fetch --all --prune
      ```

   b. 查找短名称（short-name）对应的最高功能编号：
      - 远程分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - 规格目录：检查 `specs/[0-9]+-<short-name>` 匹配目录

   c. 确定下一个可用编号：
      - 从所有三个来源提取所有数字
      - 找到最高数字 N
      - 使用N+1作为新分支编号

   d. 使用计算的编号和短名称（short-name）运行脚本 `{SCRIPT}`：
      - 传递 `--number N+1` 和 `--short-name "your-short-name"` 以及功能描述
      - Bash 示例：`{SCRIPT} --json --number 5 --short-name "user-auth" "添加用户认证"`
      - PowerShell 示例：`{SCRIPT} -Json -Number 5 -ShortName "user-auth" "添加用户认证"`

   **重要**：
   - 检查所有三个来源（远程分支、本地分支、规格目录）以找到最高数字
   - 必须精确匹配短名称（short-name）的分支/目录
   - 如果没有找到具有此短名称（short-name）的现有分支/目录，则从数字 1 开始
   - 你必须每个功能只运行一次这个脚本，以避免分支命名冲突
   - JSON 作为终端中的输出提供 - 始终引用它以获取你正在寻找的实际内容
   - JSON 输出将包含 BRANCH_NAME 和 SPEC_FILE 路径
   - 对于参数中的单引号使用转义语法或尽可能使用双引号，例如 "I'm Groot"转换为'I'\''m Groot'（或者："I'm Groot"）

3. 加载 `templates/spec-template.md` 以了解所需章节。

4. 遵循以下执行流程：

    1. 从输入中解析用户描述
       如果为空：错误"未提供功能描述"
    2. 从描述中提取关键概念
       识别：参与人、动作、数据、约束
    3. 对于不清晰的方面：
       - 根据上下文和行业标准做出明智的猜测
       - 仅当出现以下情况标记为[需要澄清：具体问题]：
         - 显著影响功能范围或用户体验的选项
         - 存在具有不同影响的多重合理解释
         - 不存在合理的默认值
       - **限制：[需要澄清]标记最多为 3 个**
       - 按影响优先级进行澄清：范围 > 安全/隐私 > 用户体验 > 技术细节
    4. 填写用户场景以及相关的测试章节
       如果没有清晰的用户流程：错误"无法确定用户场景"
    5. 生成功能需求
       每个需求必须是可测试的
       对未明确的细节使用合理的默认值（在假设章节记录假设）
    6. 定义成功标准
       创建可衡量且技术无关的结果。
       包括定量指标（时间、性能、数量）和定性衡量（用户满意度、任务完成率）
       每个标准必须在不依赖实现细节的情况下可验证
    7. 识别关键实体（如果涉及数据）
    8. 返回：成功（为下步计划准备的规格已经就绪）

5. 使用模板结构将规格写入 SPEC_FILE，将从功能描述（参数）推导的具体细节替换占位符，同时保留章节顺序和标题。

6. **规格质量验证**：编写完成初始的规格后，根据质量标准对其进行验证：

   a. **创建规格质量检查清单**：在 `FEATURE_DIR/checklists/requirements.md` 使用检查清单模板结构生成检查清单文件，包含如下这些验证条目：

      ```markdown
      # 规格质量检查清单：[功能名称]

      **目的**：在继续计划之前验证规格的完整性和质量
      **创建**：[日期]
      **功能**：[spec.md 的链接]

      ## 内容质量

      - [ ] 无实现细节（语言、框架、API）
      - [ ] 专注于用户价值和业务需求
      - [ ] 为非技术利益相关者编写
      - [ ] 所有强制章节已完成

      ## 需求完整性

      - [ ] 不存在[需要澄清]的标记
      - [ ] 需求可测试且无歧义
      - [ ] 成功标准可衡量
      - [ ] 成功标准与技术无关（无实现细节）
      - [ ] 所有验收场景已定义
      - [ ] 边缘情况已识别
      - [ ] 范围清晰界定
      - [ ] 依赖项和假设已识别

      ## 功能就绪

      - [ ] 所有功能需求都有清晰的验收标准
      - [ ] 用户场景覆盖主要流程
      - [ ] 功能符合成功标准中定义的可衡量结果
      - [ ] 实现细节未泄漏到规格中

      ## 备注

      - 标记为不完整的条目需要更新规格，然后才能 `/speckit.clarify` 或 `/speckit.plan`
      ```

   b. **运行验证检查**：根据每个检查清单条目审查规格：
      - 对于每个条目，确定通过或失败
      - 记录发现的具体问题（引用规格中相关章节）

   c. **处理验证结果**：

      - **如果所有条目通过**：标记检查清单完成并继续进行第 6 步

      - **如果条目失败（不包括标记为[需要澄清]的条目）**：
        1. 列出失败条目和具体问题
        2. 更新规格以解决每个问题
        3. 重新运行验证，直到所有条目通过（最多 3 次迭代）
        4. 如果 3 次迭代后仍然失败，在检查清单备注中记录剩余问题并警告用户

      - **如果存在[需要澄清]的标记**：
        1. 从规格中提取所有标记为[需要澄清：...]的条目
        2. **限制澄清的数量**：如果超过 3 个[需要澄清]的标记，仅保留 3 个最关键的影响（按范围/安全/用户体验）并对其余做出明智猜测
        3. 对于每个需要澄清的条目（最多 3 个），按以下格式向用户展示选项：

           ```markdown
           ## 问题 [N]: [主题]

           **上下文**：[引用相关规格章节]

           **我们需要知道的**：[来自[需要澄清]标记的具体问题]

           **建议的答案**：

           | 选项 | 答案 | 影响 |
           |--------|--------|--------------|
           | A      | [第一个建议答案] | [这对功能意味着什么] |
           | B      | [第二个建议答案] | [这对功能意味着什么] |
           | C      | [第三个建议答案] | [这对功能意味着什么] |
           | 自定义 | 提供你自己的答案 | [解释如何提供自定义输入] |

           **你的选择**：_[等待用户响应]_
           ```

        4. **关键 - 表格格式**：确保 markdown 表格格式正确：
           - 使用一致的间距，管道对齐
           - 每个单元格周围应有空格：`| 内容 |` 不是 `|内容|`
           - 标题分隔符必须至少有 3 个破折号：`|--------|`
           - 测试表格在 markdown 预览中正确渲染
        5. 顺序编号问题（Q1、Q2、Q3 - 总共最多 3 个）
        6. 在等待响应之前一起展示所有问题
        7. 等待用户回应所有问题的选择（例如，"Q1: A, Q2: 自定义 - [详情], Q3: B"）
        8. 通过将用户的选定或提供的答案替换每个[需要澄清]标记来更新规格
        9. 所有澄清解决后重新运行验证

   d. **更新检查清单**：每次验证迭代后，用当前通过/失败状态更新检查清单文件

7. 完成报告，包含分支名称、规格文件路径、检查清单结果和下一阶段（`/speckit.clarify` 或 `/speckit.plan`）的就绪性。

**注意**：脚本创建并检出新分支并在写入前初始化规格文件。

## 通用指南

## 快速指南

- 专注于用户需要的**是什么**以及**为什么**。
- 避免描述如何实施（无技术栈、API、代码结构）。
- 为业务利益相关者编写，不是开发人员。
- 不要创建嵌入在规格中的检查清单。那将是一个单独的命令。

### 章节要求

- **强制章节**：每个功能必须完成
- **可选章节**：仅在与功能相关时完成
- 当某个章节不使用时，可以完全删除它（不要保留为"N/A"）

### 对于 AI 生成

从用户提示创建此规格时：

1. **做出明智的猜测**：使用上下文、行业标准和常见模式填补空白
2. **记录假设**：在假设章节记录合理的默认值
3. **限制澄清的数量**：最多 3 个[需要澄清]标记 - 仅用于关键决策：
   - 显著影响功能范围或用户体验
   - 具有不同影响的多重合理解释
   - 缺乏合理的默认值
4. **澄清的优先级**：范围 > 安全/隐私 > 用户体验 > 技术细节
5. **像测试人员一样思考**：每个模糊需求都应该无法通过"需求可测试且无歧义"的检查条目
6. **需要澄清的常见范围**（仅当不存在合理的默认值时）：
   - 功能范围和边界（包括/排除具体用例）
   - 如果可能存在多重冲突解释，则为用户类型和权限
   - 当法律/财务上重大时的安全/合规要求

**合理的默认值的示例**（不要询问这些）：

- 数据保留：领域的行业标准实践
- 性能目标：除非指定，否则期望为标准网页/移动应用
- 错误处理：具有适当回退的友好消息
- 认证方法：网页应用的标准基于会话或 OAuth2
- 集成模式：除非指定，否则为 RESTful API

### 成功标准指南

成功标准必须是：

1. **可衡量**：包括具体指标（时间、百分比、计数、速率）
2. **技术无关**：不提及框架、语言、数据库或工具
3. **用户专注**：从用户/业务角度描述结果，不是系统内部
4. **可验证**：可以在不了解实现细节的情况下测试/验证

**好的示例**：

- "用户可以在 3 分钟内完成结帐"
- "系统支持 10,000 个并发用户"
- "95% 的搜索在 1 秒内返回结果"
- "任务完成率提高 40%"

**坏的示例**（实现专注）：

- "API 响应时间在 200ms 以下"（太技术性，使用"用户立即看到结果"）
- "数据库可以处理 1000 TPS"（实现细节，使用用户面向的指标）
- "React 组件高效渲染"（框架特定）
- "Redis 缓存命中率超过 80%"（技术特定）
