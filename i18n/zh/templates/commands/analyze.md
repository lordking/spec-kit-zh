---
description: 在任务生成后，对 spec.md、plan.md 和 tasks.md 执行非破坏性的跨工件一致性和质量分析。
scripts:
  sh: scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks
  ps: scripts/powershell/check-prerequisites.ps1 -Json -RequireTasks -IncludeTasks
---

## 用户输入

```text
$ARGUMENTS
```

（如果不为空）在进行之前，你**必须**考虑用户输入。

## 目标

在实施之前，识别三个核心工件（`spec.md`、`plan.md`、`tasks.md`）之间的不一致、重复、模糊和定义不完整的条目。此命令必须在 `/speckit.tasks` 成功生成完整的 `tasks.md` 后运行。

## 操作约束

**严格只读**：**不要**修改任何文件。输出一份结构化分析报告，并提供一份可选的修复计划（用户必须明确批准，然后才能手动调用任何后续编辑命令）。

**宪章权威**：项目宪章（`/memory/constitution.md`）在此分析范围内**不可协商**。与宪章的冲突将自动转为关键问题，并要求调整规格、计划或任务 - 而不是淡化、重新解释或静默忽略宪章中的原则。如果宪章中的原则本身需要更改，那么必须在 `/speckit.analyze` 之外的单独、明确的宪章更新流程中进行。

## 执行步骤

### 1. 初始化分析上下文

从仓库根目录运行一次 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_DIR 和 AVAILABLE_DOCS，从而推导出绝对路径：

- SPEC = FEATURE_DIR/spec.md
- PLAN = FEATURE_DIR/plan.md
- TASKS = FEATURE_DIR/tasks.md

如果任何必需文件缺失，中止并显示错误信息（指示用户运行缺失的前置命令）。
对于参数中的单引号，如 "I'm Groot"，使用转义语法：例如 'I'\''m Groot'（尽可能使用双引号："I'm Groot"）。

### 2. 加载工件（渐进式披露）

仅从每个工件加载必要的最小上下文：

**从 spec.md 加载：**

- 概述/上下文
- 功能需求
- 非功能性需求
- 用户故事
- 边界情况（如果存在）

**从 plan.md 加载：**

- 架构/技术栈选择
- 数据模型引用
- 阶段划分
- 技术约束

**从 tasks.md 加载：**

- 任务 ID
- 描述
- 阶段分组
- 并行标记 [P]
- 引用的文件路径

**从宪章加载：**

- 加载 `/memory/constitution.md` 用于原则验证

### 3. 构建语义模型

创建内部表示（不要在输出中包含原始工件）：

- **需求清单**：每个具有稳定关键词的功能与非功能性需求，（根据命令式短语推导出短代码；例如，"用户能够上传文件" → `user-can-upload-file`）
- **用户故事/操作清单**：具有验收标准的独立用户行为
- **任务覆盖率映射**：将每个任务映射到一个或多个需求或故事（通过关键词或显式引用模式如 ID 或关键短语进行推断）
- **宪章规则集**：提取原则名称和 MUST/SHOULD 规范性陈述

### 4. 检测阶段（高效率标记分析）

关注高价值发现。将发现总数限制在 50 条以内；其余部分在溢出摘要中汇总。

#### A. 重复检测

- 识别近似重复的需求
- 标记较低质量的措辞以便整合

#### B. 模糊性检测

- 标记缺乏可衡量标准的模糊形容词（快速、可扩展、安全、直观、健壮）
- 标记未解决的占位符（TODO、TKTK、???、`<placeholder>` 等）

#### C. 定义不完整

- 带有动词但缺少对象或可衡量结果的需求
- 验收标准对齐缺失的用户故事
- 引用 spec/plan 中未定义的文件或组件的任务

#### D. 宪章对齐

- 任何与强制性原则冲突的需求或计划元素
- 宪章中缺少强制性章节或质量门禁

#### E. 覆盖缺口

- 没有关联任务的需求
- 没有映射任何需求/故事的任务
- 没有在任务中反映的非功能性需求（例如性能、安全）

#### F. 不一致性

- 术语漂移（同一概念在不同文件中命名不同）
- 在计划中引用但在规格中缺失的数据实体（或反之）
- 任务排序矛盾（例如在没有依赖说明的情况下，集成任务出现在基础设置任务之前）
- 冲突的需求（例如，一个要求 Next.js 而另一个指定 Vue）

### 5. 严重性分配

使用以下启发式方法对发现的问题进行优先级排序：

- **关键**：违反宪章强制性原则、缺少核心规格工件，或零覆盖但阻塞基础功能的需求
- **高**：重复或冲突的需求、模糊的安全/性能属性、不可测试的验收标准
- **中**：术语漂移、缺少覆盖非功能性任务、定义不完整的边界情况
- **低**：风格/措辞改进、不影响执行顺序的轻微冗余

### 6. 生成简明的分析报告

输出 Markdown 报告（不写入文件），结构如下：

## 规格分析报告

| ID | 类别 | 严重性 | 位置 | 摘要 | 建议 |
|----|------|--------|--------|------|--------|
| A1 | 重复 | 高 | spec.md:L120-134 | 两个相似的需求 ... | 合并措辞；保留更清晰的版本 |

（每个发现占一行；生成以类别首字母为前缀的稳定 ID。）

**覆盖率汇总表：**

| 需求键 | 有任务？ | 任务 ID | 备注 |
|-----------------|-----------|----------|-------|

**宪章对齐问题：**（如果有）

**未映射的任务：**（如果有）

**指标：**

- 需求总数
- 任务总数
- 覆盖率百分比（拥有 >=1 任务数的需求占比）
- 模糊性问题计数
- 重复计数
- 关键问题总数

### 7. 提供后续行动建议

在报告末尾，输出简洁的后续行动块：

- 如果存在关键问题：建议在 `/speckit.implement` 之前解决
- 如果只是低/中的问题：用户可以继续，但提供改进建议
- 提供明确的命令建议：例如，"运行 /speckit.specify 进行细化"、"运行 /speckit.plan 调整架构"、"手动编辑 tasks.md 以添加 'performance-metrics' 的覆盖"

### 8. 提供修复建议

询问用户："你是否希望我为前 N 个问题提供具体的修复编辑建议吗？"（切勿自动应用这些建议）

## 操作原则

### 上下文效率

- **最少高价值标记**：专注于可操作的发现，而不是详尽的文档
- **渐进式披露**：增量加载工件；不要将所有内容都转储到分析中
- **高效的标记输出**：将发现表限制在 50 行；汇总溢出部分
- **确定性结果**：在没有更改的情况下重新运行，应产生一致的 ID 和计数

### 分析准则

- **绝不修改文件**（这是只读分析）
- **绝不虚构缺失的章节**（如果缺失，准确报告）
- **优先处理违反宪章的问题**（这些始终是关键问题）
- **使用示例而不是详尽的规则**（引用具体实例，而不是通用模式）
- **优雅地报告零问题**（输出包含覆盖率统计的成功报告）

## 上下文

{ARGS}
